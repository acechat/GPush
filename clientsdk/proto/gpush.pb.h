// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gpush.proto

#ifndef PROTOBUF_gpush_2eproto__INCLUDED
#define PROTOBUF_gpush_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "pair.pb.h"
// @@protoc_insertion_point(includes)

namespace gim {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gpush_2eproto();
void protobuf_AssignDesc_gpush_2eproto();
void protobuf_ShutdownFile_gpush_2eproto();

class LoginRequest;
class LoginResponse;
class PushRequest;
class PushResponse;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated .gim.Pair kvs = 5;
  inline int kvs_size() const;
  inline void clear_kvs();
  static const int kKvsFieldNumber = 5;
  inline const ::gim::Pair& kvs(int index) const;
  inline ::gim::Pair* mutable_kvs(int index);
  inline ::gim::Pair* add_kvs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
      kvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:gim.LoginRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* id_;
  ::std::string* token_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::gim::Pair > kvs_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gpush_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gpush_2eproto();
  #endif
  friend void protobuf_AssignDesc_gpush_2eproto();
  friend void protobuf_ShutdownFile_gpush_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string sessid = 2;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 2;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // @@protoc_insertion_point(class_scope:gim.LoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sessid();
  inline void clear_has_sessid();

  ::std::string* sessid_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gpush_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gpush_2eproto();
  #endif
  friend void protobuf_AssignDesc_gpush_2eproto();
  friend void protobuf_ShutdownFile_gpush_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequest : public ::google::protobuf::MessageLite {
 public:
  PushRequest();
  virtual ~PushRequest();

  PushRequest(const PushRequest& from);

  inline PushRequest& operator=(const PushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequest* other);

  // implements Message ----------------------------------------------

  PushRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequest& from);
  void MergeFrom(const PushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  inline ::std::string* release_from_sessid();
  inline void set_allocated_from_sessid(::std::string* from_sessid);

  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  inline ::std::string* release_to_sessid();
  inline void set_allocated_to_sessid(::std::string* to_sessid);

  // required string sn = 3;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 3;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:gim.PushRequest)
 private:
  inline void set_has_from_sessid();
  inline void clear_has_from_sessid();
  inline void set_has_to_sessid();
  inline void clear_has_to_sessid();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string* from_sessid_;
  ::std::string* to_sessid_;
  ::std::string* sn_;
  ::std::string* payload_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gpush_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gpush_2eproto();
  #endif
  friend void protobuf_AssignDesc_gpush_2eproto();
  friend void protobuf_ShutdownFile_gpush_2eproto();

  void InitAsDefaultInstance();
  static PushRequest* default_instance_;
};
// -------------------------------------------------------------------

class PushResponse : public ::google::protobuf::MessageLite {
 public:
  PushResponse();
  virtual ~PushResponse();

  PushResponse(const PushResponse& from);

  inline PushResponse& operator=(const PushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushResponse* other);

  // implements Message ----------------------------------------------

  PushResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushResponse& from);
  void MergeFrom(const PushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  inline ::std::string* release_from_sessid();
  inline void set_allocated_from_sessid(::std::string* from_sessid);

  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  inline ::std::string* release_to_sessid();
  inline void set_allocated_to_sessid(::std::string* to_sessid);

  // required string sn = 3;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 3;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.PushResponse)
 private:
  inline void set_has_from_sessid();
  inline void clear_has_from_sessid();
  inline void set_has_to_sessid();
  inline void clear_has_to_sessid();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string* from_sessid_;
  ::std::string* to_sessid_;
  ::std::string* sn_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gpush_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gpush_2eproto();
  #endif
  friend void protobuf_AssignDesc_gpush_2eproto();
  friend void protobuf_ShutdownFile_gpush_2eproto();

  void InitAsDefaultInstance();
  static PushResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string id = 1;
inline bool LoginRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& LoginRequest::id() const {
  return *id_;
}
inline void LoginRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* LoginRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 2;
inline bool LoginRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LoginRequest::type() const {
  return type_;
}
inline void LoginRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string token = 3;
inline bool LoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginRequest::token() const {
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 4;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginRequest::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .gim.Pair kvs = 5;
inline int LoginRequest::kvs_size() const {
  return kvs_.size();
}
inline void LoginRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::gim::Pair& LoginRequest::kvs(int index) const {
  return kvs_.Get(index);
}
inline ::gim::Pair* LoginRequest::mutable_kvs(int index) {
  return kvs_.Mutable(index);
}
inline ::gim::Pair* LoginRequest::add_kvs() {
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
LoginRequest::kvs() const {
  return kvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
LoginRequest::mutable_kvs() {
  return &kvs_;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 status = 1;
inline bool LoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LoginResponse::status() const {
  return status_;
}
inline void LoginResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string sessid = 2;
inline bool LoginResponse::has_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& LoginResponse::sessid() const {
  return *sessid_;
}
inline void LoginResponse::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* LoginResponse::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PushRequest

// optional string from_sessid = 1;
inline bool PushRequest::has_from_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequest::set_has_from_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequest::clear_has_from_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequest::clear_from_sessid() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    from_sessid_->clear();
  }
  clear_has_from_sessid();
}
inline const ::std::string& PushRequest::from_sessid() const {
  return *from_sessid_;
}
inline void PushRequest::set_from_sessid(const ::std::string& value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void PushRequest::set_from_sessid(const char* value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void PushRequest::set_from_sessid(const char* value, size_t size) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushRequest::mutable_from_sessid() {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}
inline ::std::string* PushRequest::release_from_sessid() {
  clear_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_sessid_;
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushRequest::set_allocated_from_sessid(::std::string* from_sessid) {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (from_sessid) {
    set_has_from_sessid();
    from_sessid_ = from_sessid;
  } else {
    clear_has_from_sessid();
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_sessid = 2;
inline bool PushRequest::has_to_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequest::set_has_to_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequest::clear_has_to_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequest::clear_to_sessid() {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    to_sessid_->clear();
  }
  clear_has_to_sessid();
}
inline const ::std::string& PushRequest::to_sessid() const {
  return *to_sessid_;
}
inline void PushRequest::set_to_sessid(const ::std::string& value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void PushRequest::set_to_sessid(const char* value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void PushRequest::set_to_sessid(const char* value, size_t size) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushRequest::mutable_to_sessid() {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}
inline ::std::string* PushRequest::release_to_sessid() {
  clear_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_sessid_;
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushRequest::set_allocated_to_sessid(::std::string* to_sessid) {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (to_sessid) {
    set_has_to_sessid();
    to_sessid_ = to_sessid;
  } else {
    clear_has_to_sessid();
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sn = 3;
inline bool PushRequest::has_sn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequest::set_has_sn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequest::clear_has_sn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequest::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& PushRequest::sn() const {
  return *sn_;
}
inline void PushRequest::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushRequest::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushRequest::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushRequest::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* PushRequest::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushRequest::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 4;
inline bool PushRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PushRequest::type() const {
  return type_;
}
inline void PushRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes payload = 5;
inline bool PushRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& PushRequest::payload() const {
  return *payload_;
}
inline void PushRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PushRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PushRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* PushRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushRequest::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PushResponse

// optional string from_sessid = 1;
inline bool PushResponse::has_from_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushResponse::set_has_from_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushResponse::clear_has_from_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushResponse::clear_from_sessid() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    from_sessid_->clear();
  }
  clear_has_from_sessid();
}
inline const ::std::string& PushResponse::from_sessid() const {
  return *from_sessid_;
}
inline void PushResponse::set_from_sessid(const ::std::string& value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void PushResponse::set_from_sessid(const char* value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void PushResponse::set_from_sessid(const char* value, size_t size) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushResponse::mutable_from_sessid() {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}
inline ::std::string* PushResponse::release_from_sessid() {
  clear_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_sessid_;
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushResponse::set_allocated_from_sessid(::std::string* from_sessid) {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (from_sessid) {
    set_has_from_sessid();
    from_sessid_ = from_sessid;
  } else {
    clear_has_from_sessid();
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_sessid = 2;
inline bool PushResponse::has_to_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushResponse::set_has_to_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushResponse::clear_has_to_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushResponse::clear_to_sessid() {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    to_sessid_->clear();
  }
  clear_has_to_sessid();
}
inline const ::std::string& PushResponse::to_sessid() const {
  return *to_sessid_;
}
inline void PushResponse::set_to_sessid(const ::std::string& value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void PushResponse::set_to_sessid(const char* value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void PushResponse::set_to_sessid(const char* value, size_t size) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushResponse::mutable_to_sessid() {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}
inline ::std::string* PushResponse::release_to_sessid() {
  clear_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_sessid_;
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushResponse::set_allocated_to_sessid(::std::string* to_sessid) {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (to_sessid) {
    set_has_to_sessid();
    to_sessid_ = to_sessid;
  } else {
    clear_has_to_sessid();
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sn = 3;
inline bool PushResponse::has_sn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushResponse::set_has_sn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushResponse::clear_has_sn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushResponse::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& PushResponse::sn() const {
  return *sn_;
}
inline void PushResponse::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushResponse::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushResponse::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushResponse::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* PushResponse::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushResponse::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 4;
inline bool PushResponse::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushResponse::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PushResponse::status() const {
  return status_;
}
inline void PushResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gpush_2eproto__INCLUDED
